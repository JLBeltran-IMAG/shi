#!/usr/bin/env python3

import numpy as np
import skimage.io as io

import matplotlib.pyplot as plt
from matplotlib.widgets import Button

import subprocess as subprocess
import argparse
import sys
from pathlib import Path
import logging

# Path to source
current_dir = Path(__file__).resolve().parent
src_dir = current_dir.joinpath("src")
script_dir = current_dir.joinpath("scripts")
cache_dir = current_dir.joinpath("cache")
tmp_dir = current_dir.joinpath("tmp")

sys.path.insert(0, str(src_dir))

import spatial_harmonics as spatial_harmonics
import directories as directories
import utils
import export
import math_utils
import corrections
import crop
import angles_correction


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)




def my_parser():
    """
    Configures and returns an ArgumentParser for the SHI software (Spatial Harmonic Imaging), a modality for
    Multicontrast X-ray Imaging analysis. This parser enables multiple subcommands, each designed for a specific
    functionality within the software.

    Program: SHI
    Description: Automated implementation of Spatial Harmonic Imaging with options for calculation, morphostructural
    analysis, angle correction, and cleanup of temporary files.

    Main Subcommands:
        - calculate: Executes the SHI method.
        - morphostructural: Runs morphostructural analysis.
        - preprocessing: Performs preprocessing corrections.
        - clean: Removes temporary files generated by the SHI method to free memory.

    Returns:
        ArgumentParser: Configured with all subcommands and arguments for the SHI software.
    """

    main_parser = argparse.ArgumentParser(
        prog="SHI",
        description="%(prog)s: This software is an automated implementation of Spatial Harmonic Imaging, a modality of Multicontrast X-ray Imaging",
    )

    subparsers = main_parser.add_subparsers(dest="command", required=True)

    # Defining subparsers for various functionalities
    parser_shi = subparsers.add_parser("calculate", help="This subcommand executes the SHI method.")
    parser_morfo = subparsers.add_parser("morphostructural", help="This subcommand performs morphostructural analysis.")
    parser_angle = subparsers.add_parser(
        "preprocessing", help="This subcommand corrects angle alignment of optical components."
    )
    parser_clean = subparsers.add_parser(
        "clean", help="This subcommand deletes temporary files generated by the SHI method to avoid memory shortages."
    )

    # Main argument for SHI
    parser_shi.add_argument("-m", "--mask_period", required=True, type=str, help="Number of projected pixels in the mask.")

    # ---------------------------------------- Subparser calculate ----------------------------------------------------
    # Option 1: User-defined input images
    parser_shi.add_argument("-i", "--images", type=str, help="Path to sample image(s)")
    parser_shi.add_argument("-f", "--flat", type=str, help="Path to flat image(s)")
    parser_shi.add_argument("-d", "--dark", type=str, help="Path to dark image(s)")
    parser_shi.add_argument("-b", "--bright", type=str, help="Path to bright image(s)")

    # Option 2: Automatically detected input images
    parser_shi.add_argument(
        "--all-2d", action="store_true", help="Executes the SHI-2D method in the current folder without specifying inputs"
    )
    parser_shi.add_argument(
        "--all-3d", action="store_true", help="Executes the SHI-CT method in the current folder without specifying inputs"
    )
    parser_shi.add_argument("--average", action="store_true", help="Apply averaging")
    parser_shi.add_argument("--export", action="store_true", help="Apply averaging")
    parser_shi.add_argument("--angle-after", action="store_true", help="Apply angle correction after measurements")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser morphostructural ---------------------------------------------
    # Morphostructural subcommand
    parser_morfo.add_argument("--morphostructural", action="store_true", help="Apply morphostructural analysis")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser preprocessing --------------------------------------------------------
    # Angle correction subcommand
    # parser_angle.add_argument("--angle-before", action="store_true", help="correct angle or not, before measurements")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser clean --------------------------------------------------------
    # Clean subcommand
    parser_clean.add_argument("--clear-cache", action="store_true", help="Clear cache generated by SHI")
    parser_clean.add_argument(
        "--clear-extra", action="store_true", help="Clear extra files generated by SHI after calculate"
    )
    # -----------------------------------------------------------------------------------------------------------------

    # ----------------- Opciones nuevas ----------------------------------------
    # parser.add_argument("--test", action = "store_true", help = "")

    return main_parser


def run_commands(cmd, cwd):
    """Execute a commands via subprocess.run."""
    subprocess.run(cmd, cwd=cwd, capture_output=True, text=True)


if __name__ == "__main__":
    parser = my_parser()
    args = parser.parse_args()

    if args.command == "calculate":
        mask_period = int(args.mask_period)

        logger.info("Executing 'calculate' command with mask_period: %d", mask_period)

        if args.all_2d or args.all_3d:
            if args.all_2d:
                logger.info("Executing SHI-2D mode")
            elif args.all_3d:
                logger.info("Executing SHI-CT mode")
            measurement_directory = Path.cwd()
            images_path = list((measurement_directory / "sample").iterdir())
            dark_path = measurement_directory / "dark"
            flat_path = measurement_directory / "flat"
            bright_path = measurement_directory / "bright"

            logger.info("Automatic image detection activated in directory: %s", measurement_directory)

        else:
            images_path = Path(args.images).iterdir()
            dark_path = Path(args.dark)
            flat_path = Path(args.flat)
            bright_path = Path(args.bright)

            logger.info("Using user-specified image paths.")

        for image_path in images_path:
            logger.info("Processing measurement: %s", image_path)

            # Before dark field correction, crop the Region Of Interest (ROI)
            output = image_path.stem
            fig, ax = plt.subplots()

            # Select first TIFF file within image directory
            tif_files = list(Path(image_path).glob("*.tif"))
            if not tif_files:
                logger.error("No .tif files found in %s", image_path)
                raise ValueError(f"No .tif files found in {image_path}")

            path_to_crop = tif_files[0]
            image = io.imread(path_to_crop)

            if args.angle_after:
                path_to_ang = flat_path if flat_path is not None else image_path
                tif_ang_files = list(Path(path_to_ang).glob("*.tif"))

                if not tif_ang_files:
                    logger.error("No .tif files found for angle correction in %s", path_to_ang)
                    deg = 0
                else:
                    path_to_angle_correction = tif_ang_files[0]
                    image_angle = io.imread(path_to_angle_correction)
                    cords = angles_correction.extracting_coordinates_of_peaks(image_angle)
                    deg = angles_correction.calculating_angles_of_peaks_average(cords)
            else:
                deg = 0

            crop_image = crop.cropImage(ax, image, tmp_dir)

            ax_button1 = fig.add_axes([0.8, 0.80, 0.15, 0.03])
            button_to_pw1 = Button(ax_button1, label="Set ROI")
            button_to_pw1.on_clicked(lambda event: crop_image.setting_crop())

            ax_button2 = fig.add_axes([0.8, 0.75, 0.15, 0.03])
            button_to_pw2 = Button(ax_button2, label="Export image + inset")
            button_to_pw2.on_clicked(lambda event: crop_image.exporting_image_inset())

            plt.show()

            crop_file = tmp_dir / "crop.txt"
            if not crop_file.exists():
                logger.error("Crop file not found: %s", crop_file)
                raise ValueError(f"Crop file not found: {crop_file}")
            crop_from_tmptxt = np.rint(np.loadtxt(crop_file.as_posix())).astype(int)


            if dark_path is not None:
                corrections.correct_darkfield(
                    path_to_dark=dark_path, path_to_images=flat_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                corrections.correct_darkfield(
                    path_to_dark=dark_path, path_to_images=image_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )

                if bright_path is not None:
                    corrections.correct_darkfield(
                        path_to_dark=dark_path, path_to_images=bright_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                    )

                    corrections.correct_brightfield(path_to_bright=bright_path, path_to_images=flat_path)
                    corrections.correct_brightfield(path_to_bright=bright_path, path_to_images=image_path)

                foldername_to = "corrected_images"

            else:
                corrections.crop_without_corrections(
                    path_to_images=image_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                corrections.crop_without_corrections(
                    path_to_images=flat_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )

                foldername_to = "crop_without_correction"

            path_to_corrected_images = (Path(image_path) / foldername_to).as_posix()
            path_to_images, path_to_result = directories.create_result_subfolders(
                directory_for_files=path_to_corrected_images, folders_for_result=output, sample_folder_name=""
            )

            type_of_contrast = ("absorption", "scattering", "phase", "phasemap")
            if flat_path is None:
                spatial_harmonics.execute_SHI(path_to_images, path_to_result, mask_period)
            else:
                path_to_corrected_flat = Path(flat_path).joinpath(foldername_to).as_posix()

                path_to_flat, path_to_flat_result = directories.create_result_subfolders(
                    directory_for_files=path_to_corrected_flat,
                    folders_for_result=path_to_result.name,
                    sample_folder_name="flat",
                )

                spatial_harmonics.execute_SHI(path_to_flat, path_to_flat_result, mask_period, True)
                spatial_harmonics.execute_SHI(path_to_images, path_to_result, mask_period, False)
                path_to_result = utils.create_corrections_folder(path_to_result)

                for contrast in type_of_contrast:
                    path_to_average_flat = math_utils.average_flat_harmonics(path_to_flat_result, type_of_contrast=contrast)
                    corrections.correct_flatmask(path_to_result, path_to_average_flat, type_of_contrast=contrast)

                if args.all_2d:
                    pass
                elif args.all_3d:
                    commands = ["python", "dir_ct.py", path_to_result.as_posix()]
                    subprocess.run(commands, cwd=script_dir, capture_output=True, text=True)
                else:
                    logger.error("No mode selected (neither all_2d nor all_3d specified)")
                    raise ValueError("No mode selected (neither all_2d nor all_3d specified)")

            if args.average:
                for contrast in type_of_contrast:
                    path_avg = path_to_result.joinpath(contrast, "flat_corrections").as_posix()
                    avg_commands = ["python", "avg.py", "--path", path_avg, "-t", contrast]
                    logger.info("Running average command: %s", avg_commands)
                    subprocess.run(avg_commands, cwd=script_dir, capture_output=True, text=True)

            if args.export:
                logger.info("Exporting results to %s", path_to_result)
                export.export_results(path_to_result)

    elif args.command == "clean":
        if args.clear_cache:
            for content in cache_dir.iterdir():
                logger.info("Removing cache content: %s", content)
                subprocess.run(["rm", "-rf", content.as_posix()], check=True)
        # elif args.clear_extra:
        #     measurement_directory = Path.cwd()
        #     for content in measurement_directory.iterdir():
        #         subprocess.run(["rm", "-rf", content.as_posix()], check=True)
        else:
            logger.error("No cleaning option specified (neither --clear-cache nor --clear-extra)")
            raise ValueError("No cleaning option specified. Use --clear-cache or --clear-extra.")

    elif args.command == "morphostructural":
        if args.morphostructural:
            cmd = ["python", "morphos.py", "--select_folder", "--manually"]
            logger.info("Executing morphostructural analysis with command: %s", cmd)
            subprocess.run(cmd, cwd=script_dir, capture_output=True, text=True)
        else:
            logger.error("Unknown command: %s", args.command)
            raise ValueError(f"Unknown command: {args.command}")

    sys.exit()

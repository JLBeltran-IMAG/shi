#!/usr/bin/env python3

import numpy as np
import skimage.io as io
from tifffile import imread

import matplotlib.pyplot as plt
from matplotlib.widgets import Button

import subprocess as subprocess
import argparse
import sys
from pathlib import Path

# Path to my module
current_dir = Path(__file__).resolve().parent
src_dir = current_dir.joinpath("src")
script_dir = current_dir.joinpath("scripts")
cache_dir = current_dir.joinpath("cache")
tmp_dir = current_dir.joinpath("tmp")

sys.path.insert(0, str(src_dir))

import spatial_harmonics as spatial_harmonics
import directories as directories
import utils
import export
import math_utils
import corrections
import corrections_ct
import crop
import angles_correction


def execute_SHI(path_to_images, path_to_result, mask_period, flat):
    """
    Execute spatial harmonics analysis on a set of images.

    This function performs spatial harmonics analysis on a set of images and exports the results to the specified directory.

    Parameters
    ----------
    path_to_images : list of str
        A list of paths to the images for analysis.
    path_to_result : str
        The path to the directory where the results will be exported.
    mask_period : int
        The period of the mask used in the analysis.

    """
    for path in path_to_images:
        img = imread(path).astype(np.float32)

        wavevector_kx, wavevector_ky, fft_img = spatial_harmonics.squared_fast_fourier_transform_linear_and_logarithmic(
            img, mask_period
        )
        harmonics, labels = spatial_harmonics.spatial_harmonics_of_fourier_spectrum(
            fft_img, wavevector_ky, wavevector_kx, flat
        )

        absorption = spatial_harmonics.contrast_retrieval_individual_members(harmonics[0], type_of_contrast="absorption")
        directories.export_result_to(absorption, path.stem, path_to_result, "absorption")

        differential_phase_horizontal = spatial_harmonics.differential_phase_contrast(absorption, label="horizontal")
        differential_phase_vertical = spatial_harmonics.differential_phase_contrast(absorption, label="vertical")

        directories.export_result_to(differential_phase_horizontal, path.stem + "_" + "horizontal", path_to_result, "phase")
        directories.export_result_to(differential_phase_vertical, path.stem + "_" + "vertical", path_to_result, "phase")

        for idx in range(1, len(labels)):
            scattering = spatial_harmonics.contrast_retrieval_individual_members(
                harmonics[idx], type_of_contrast="scattering"
            )
            directories.export_result_to(scattering, path.stem + "_" + labels[idx], path_to_result, "scattering")

            phasemap = spatial_harmonics.contrast_retrieval_individual_members(
                harmonics[idx], type_of_contrast="phasemap", label=labels[idx]
            )
            directories.export_result_to(phasemap, path.stem + "_" + labels[idx], path_to_result, "phasemap")


def my_parser():
    """
    Configures and returns an ArgumentParser for the SHI software (Spatial Harmonic Imaging), a modality for
    Multicontrast X-ray Imaging analysis. This parser enables multiple subcommands, each designed for a specific
    functionality within the software.

    Program: SHI
    Description: Automated implementation of Spatial Harmonic Imaging with options for calculation, morphostructural
    analysis, angle correction, and cleanup of temporary files.

    Main Subcommands:
        - calculate: Executes the SHI method.
        - morphostructural: Runs morphostructural analysis.
        - angle: Performs angle correction for alignment of optical components.
        - clean: Removes temporary files generated by the SHI method to free memory.

    Returns:
        ArgumentParser: Configured with all subcommands and arguments for the SHI software.
    """

    main_parser = argparse.ArgumentParser(
        prog="SHI",
        description="%(prog)s: This software is an automated implementation of Spatial Harmonic Imaging, a modality of Multicontrast X-ray Imaging",
    )

    subparsers = main_parser.add_subparsers(dest="comando", required=True)

    # Defining subparsers for various functionalities
    parser_shi = subparsers.add_parser("calculate", help="This subcommand executes the SHI method.")
    parser_morfo = subparsers.add_parser("morphostructural", help="This subcommand performs morphostructural analysis.")
    parser_angle = subparsers.add_parser("angle", help="This subcommand corrects angle alignment of optical components.")
    parser_clean = subparsers.add_parser(
        "clean", help="This subcommand deletes temporary files generated by the SHI method to avoid memory shortages."
    )

    # Main argument for SHI
    parser_shi.add_argument("-m", "--mask_period", required=True, type=str, help="Number of projected pixels in the mask.")

    # ---------------------------------------- Subparser calculate ----------------------------------------------------
    # Option 1: User-defined input images
    parser_shi.add_argument("-i", "--images", type=str, help="Path to sample image(s)")
    parser_shi.add_argument("-d", "--dark", type=str, help="Path to dark image(s)")
    parser_shi.add_argument("-f", "--flat", type=str, help="Path to flat image(s)")
    parser_shi.add_argument("-b", "--bright", type=str, help="Path to bright image(s)")

    # Option 2: Automatically detected input images
    parser_shi.add_argument(
        "--all-2d", action="store_true", help="Executes the SHI-2D method in the current folder without specifying inputs"
    )
    parser_shi.add_argument(
        "--all-3d", action="store_true", help="Executes the SHI-CT method in the current folder without specifying inputs"
    )
    parser_shi.add_argument("--average", action="store_true", help="Apply averaging")
    parser_shi.add_argument("--export", action="store_true", help="Apply averaging")
    parser_shi.add_argument("--angle-after", action="store_true", help="Apply angle correction after measurements")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser morphostructural ---------------------------------------------
    # Morphostructural subcommand
    parser_morfo.add_argument("--morphostructural", action="store_true", help="Apply morphostructural analysis")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser angle --------------------------------------------------------
    # Angle correction subcommand
    # parser_angle.add_argument("--angle-before", action="store_true", help="correct angle or not, before measurements")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser clean --------------------------------------------------------
    # Clean subcommand
    parser_clean.add_argument("--clear-cache", action="store_true", help="Clear cache generated by SHI")
    # parser_clean.add_argument("--clear-crops", action="store_true", help="")
    # -----------------------------------------------------------------------------------------------------------------

    # ----------------- Opciones nuevas ----------------------------------------
    # parser.add_argument("--test", action = "store_true", help = "")

    return main_parser


if __name__ == "__main__":
    args = my_parser()
    args = args.parse_args()

    if args.comando == "calculate":
        mask_period = int(args.mask_period)

        if args.all_2d or args.all_3d:
            measurement_directory = Path().cwd()

            content = measurement_directory.iterdir()

            images_path = measurement_directory.joinpath("sample").iterdir()
            dark_path = measurement_directory.joinpath("dark")
            flat_path = measurement_directory.joinpath("flat")
            # bright_path = measurement_directory.joinpath("bright")

        else:
            images_path = Path(args.images).iterdir()
            dark_path = Path(args.dark)
            flat_path = Path(args.flat)
            # bright_path = Path(args.bright)

        # Before dark field correction, crop the Region Of Interest (ROI)
        for image_path in images_path:
            output = image_path.stem
            fig, ax = plt.subplots()
            path_to_crop = list(Path(image_path).glob("*.tif"))[0]

            image = io.imread(path_to_crop)

            if args.angle_after:
                if flat_path is not None:
                    path_to_ang = flat_path
                else:
                    path_to_ang = image_path

                path_to_angle_correction = list(Path(path_to_ang).glob("*.tif"))[0]
                image_angle = io.imread(path_to_angle_correction)
                cords = angles_correction.extracting_coordinates_of_peaks(image_angle)
                deg = angles_correction.calculating_angles_of_peaks_average(cords)
            else:
                deg = 0

            crop_image = crop.cropImage(ax, image, tmp_dir)

            ax_button1 = fig.add_axes([0.8, 0.80, 0.15, 0.03])
            button_to_pw1 = Button(ax_button1, label="Set ROI")
            button_to_pw1.on_clicked(lambda event: crop_image.setting_crop())

            ax_button2 = fig.add_axes([0.8, 0.75, 0.15, 0.03])
            button_to_pw2 = Button(ax_button2, label="Export image + inset")
            button_to_pw2.on_clicked(lambda event: crop_image.exporting_image_inset())

            plt.show()

            crop_from_tmptxt = np.rint(np.loadtxt("{}/crop.txt".format(tmp_dir))).astype(int)

            if dark_path is not None:
                corrections.correct_darkfield(
                    path_to_dark=dark_path, path_to_images=image_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                if flat_path is not None:
                    corrections.correct_darkfield(
                        path_to_dark=dark_path, path_to_images=flat_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                    )
                # corrections.correct_darkfield(path_to_dark = dark_path, path_to_images = args.bright, crop = crop_from_tmptxt, allow_crop = True)
                foldername_to = "corrected_images"
            else:
                corrections.crop_without_corrections(
                    path_to_images=image_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                foldername_to = "crop_without_correction"

            if args.bright is not None:
                pass
                # Execute the bright correction of flat field correction
                # Ejecutar bright para flat
                # Ejecutar bright para images

            path_to_corrected_images = Path(image_path).joinpath(foldername_to).as_posix()
            path_to_images, path_to_result = directories.create_result_subfolders(
                directory_for_files=path_to_corrected_images, folders_for_result=output, sample_folder_name=""
            )

            if flat_path is None:
                execute_SHI(path_to_images, path_to_result, mask_period)
            else:
                corrections.crop_without_corrections(
                    path_to_images=flat_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                path_to_corrected_flat = Path(flat_path).joinpath(foldername_to).as_posix()

                path_to_flat, path_to_flat_result = directories.create_result_subfolders(
                    directory_for_files=path_to_corrected_flat,
                    folders_for_result=path_to_result.name,
                    sample_folder_name="flat",
                )

                execute_SHI(path_to_flat, path_to_flat_result, mask_period, True)
                path_to_result = utils.create_corrections_folder(path_to_result, args.all_3d)

                execute_SHI(path_to_images, path_to_result, mask_period, False)

                path_to_average_flat_absorption = math_utils.average_flat_harmonics(
                    path_to_flat_result, type_of_contrast="absorption"
                )
                path_to_average_flat_scattering = math_utils.average_flat_harmonics(
                    path_to_flat_result, type_of_contrast="scattering"
                )
                path_to_average_flat_phase = math_utils.average_flat_harmonics(path_to_flat_result, type_of_contrast="phase")
                path_to_average_flat_phasemap = math_utils.average_flat_harmonics(
                    path_to_flat_result, type_of_contrast="phasemap"
                )

                if args.all_2d:
                    corrections.correct_flatmask(
                        path_to_result, path_to_average_flat_absorption, type_of_contrast="absorption"
                    )
                    corrections.correct_flatmask(
                        path_to_result, path_to_average_flat_scattering, type_of_contrast="scattering"
                    )
                    corrections.correct_flatmask(path_to_result, path_to_average_flat_phase, type_of_contrast="phase")
                    corrections.correct_flatmask(path_to_result, path_to_average_flat_phasemap, type_of_contrast="phasemap")

                elif args.all_3d:
                    corrections_ct.correct_flatmask(
                        path_to_result, path_to_average_flat_absorption, type_of_contrast="absorption"
                    )
                    corrections_ct.correct_flatmask(
                        path_to_result, path_to_average_flat_scattering, type_of_contrast="scattering"
                    )
                    corrections_ct.correct_flatmask(path_to_result, path_to_average_flat_phase, type_of_contrast="phase")
                    corrections_ct.correct_flatmask(
                        path_to_result, path_to_average_flat_phasemap, type_of_contrast="phasemap"
                    )

                else:
                    print("No mode all selected")

            if args.average:
                commands = [
                    [
                        "python",
                        "avg.py",
                        "--path",
                        path_to_result.joinpath("absorption", "flat_corrections").as_posix(),
                        "-t",
                        "absorption",
                    ],
                    [
                        "python",
                        "avg.py",
                        "--path",
                        path_to_result.joinpath("scattering", "flat_corrections").as_posix(),
                        "-t",
                        "scattering",
                    ],
                    [
                        "python",
                        "avg.py",
                        "--path",
                        path_to_result.joinpath("phase", "flat_corrections").as_posix(),
                        "-t",
                        "phase",
                    ],
                    [
                        "python",
                        "avg.py",
                        "--path",
                        path_to_result.joinpath("phasemap", "flat_corrections").as_posix(),
                        "-t",
                        "phasemap",
                    ],
                ]

                subprocess.run(commands[0], cwd=script_dir, capture_output=True, text=True)
                subprocess.run(commands[1], cwd=script_dir, capture_output=True, text=True)
                subprocess.run(commands[2], cwd=script_dir, capture_output=True, text=True)
                subprocess.run(commands[3], cwd=script_dir, capture_output=True, text=True)

            if args.export:
                export.export_results(path_to_result)

    elif args.comando == "clean":
        if args.clear_cache:
            for content in cache_dir.iterdir():
                subprocess.run(["rm", "-rf", content.as_posix()], check=True)
        else:
            pass

    elif args.comando == "morphostructural":
        if args.morphostructural:
            command = ["python", "morphos.py", "--select_folder", "--manually"]
            subprocess.run(command, cwd=script_dir, capture_output=True, text=True)

    sys.exit()

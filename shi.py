#!/usr/bin/env python3

import numpy as np
import skimage.io as io
import subprocess
import argparse
import sys
import logging
from pathlib import Path

# Path to source
current_dir = Path(__file__).resolve().parent
script_dir = current_dir.joinpath("scripts")
cache_dir = current_dir.joinpath("cache")
tmp_dir = current_dir.joinpath("tmp")
src_dir = current_dir.joinpath("src")

# Adding source directory to sys.path
sys.path.append(str(src_dir))

# Importing modules from the source directory
import spatial_harmonics as spatial_harmonics
import directories as directories
import corrections
import crop_tk
import angles_correction
import correcting_stripes


logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


def my_parser():
    """
    Configures and returns an ArgumentParser for the SHI software (Spatial Harmonic Imaging), a modality for
    Multicontrast X-ray Imaging analysis. This parser enables multiple subcommands, each designed for a specific
    functionality within the software.

    Program: SHI
    Description: Automated implementation of Spatial Harmonic Imaging with options for calculation, morphostructural
    analysis, angle correction, and cleanup of temporary files.

    Main Subcommands:
        - calculate: Executes the SHI method.
        - morphostructural: Runs morphostructural analysis.
        - preprocessing: Performs preprocessing corrections.
        - clean: Removes temporary files generated by the SHI method to free memory.

    Returns:
        ArgumentParser: Configured with all subcommands and arguments for the SHI software.
    """

    main_parser = argparse.ArgumentParser(
        prog="SHI",
        description="%(prog)s: This software is an automated implementation of Spatial Harmonic Imaging, a modality of Multicontrast X-ray Imaging",
    )

    subparsers = main_parser.add_subparsers(dest="command", required=True)

    # Defining subparsers for various functionalities
    parser_shi = subparsers.add_parser("calculate", help="This subcommand executes the SHI method.")
    parser_morfo = subparsers.add_parser("morphostructural", help="This subcommand performs morphostructural analysis.")
    parser_prep = subparsers.add_parser(
        "preprocessing", help="This subcommand corrects angle alignment of optical components."
    )
    parser_clean = subparsers.add_parser(
        "clean", help="This subcommand deletes temporary files generated by the SHI method to avoid memory shortages."
    )

    # Main argument for SHI
    parser_shi.add_argument("-m", "--mask_period", required=True, type=str, help="Number of projected pixels in the mask.")

    # ---------------------------------------- Subparser calculate ----------------------------------------------------
    # Option 1: User-defined input images
    parser_shi.add_argument("-i", "--images", type=str, help="Path to sample image(s)")
    parser_shi.add_argument("-f", "--flat", type=str, help="Path to flat image(s)")
    parser_shi.add_argument("-d", "--dark", type=str, help="Path to dark image(s)")
    parser_shi.add_argument("-b", "--bright", type=str, help="Path to bright image(s)")


    # Option 2: Automatically detected input images
    parser_shi.add_argument(
        "--all-2d", action="store_true", help="Executes the SHI-2D method in the current folder without specifying inputs"
    )
    parser_shi.add_argument(
        "--all-3d", action="store_true", help="Executes the SHI-CT method in the current folder without specifying inputs"
    )
    parser_shi.add_argument("--average", action="store_true", help="Apply averaging")
    parser_shi.add_argument("--export", action="store_true", help="Apply export")
    parser_shi.add_argument("--angle-after", action="store_true", help="Apply angle correction after measurements")
    parser_shi.add_argument("--unwrap-phase", type=str, default=None, help="Select phase unwrapping method: "
    "branch_cut - 'Goldsteinâ€™s Branch-Cut Unwrapping (Simplified)', "
    "least_squares - 'Least-Squares Phase Unwrapping using FFT', "
    "quality_guided - 'Quality-Guided Phase Unwrapping', "
    "min_lp - 'Minimum Lp-Norm Phase Unwrapping', "
    "'empty = default (dont write anything) - Algorithm based on sorting by reliability following a noncontinuous path'")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser morphostructural ---------------------------------------------
    # Morphostructural subcommand
    parser_morfo.add_argument("--morphostructural", action="store_true", help="Apply morphostructural analysis")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser preprocessing --------------------------------------------------------
    # Preprocessing subcommand
    parser_prep.add_argument("--stripes", action="store_true", help="correct stripes deleting them")
    # parser_prep.add_argument("--stripes-user", action="store_true", help="mas adelante")
    # -----------------------------------------------------------------------------------------------------------------

    # ---------------------------------------- Subparser clean --------------------------------------------------------
    # Clean subcommand
    parser_clean.add_argument("--clear-cache", action="store_true", help="Clear cache generated by SHI")
    parser_clean.add_argument(
        "--clear-extra", action="store_true", help="Clear extra files generated by SHI after calculate"
    )
    # -----------------------------------------------------------------------------------------------------------------

    # ----------------- Opciones nuevas ----------------------------------------
    # parser.add_argument("--test", action = "store_true", help = "")

    return main_parser


def run_commands(cmd, cwd):
    """Execute a commands via subprocess.run."""
    subprocess.run(cmd, cwd=cwd, capture_output=True, text=True)


if __name__ == "__main__":
    parser = my_parser()
    args = parser.parse_args()

    if args.command == "calculate":
        mask_period = int(args.mask_period)
        unwrap = args.unwrap_phase

        logger.info("Executing 'calculate' command with mask_period: %d", mask_period)

        if args.all_2d or args.all_3d:
            if args.all_2d:
                logger.info("Executing SHI processing in 2D mode")
            elif args.all_3d:
                logger.info("Executing SHI processing in CT mode")

            measurement_directory = Path.cwd()
            images_path = list((measurement_directory / "sample").iterdir())
            dark_path = measurement_directory / "dark"
            flat_path = measurement_directory / "flat"
            bright_path = measurement_directory / "bright"

            logger.info("Automatic image detection activated in directory: %s", measurement_directory)

        else:
            images_path = Path(args.images).iterdir()
            dark_path = Path(args.dark)
            flat_path = Path(args.flat)
            bright_path = Path(args.bright)

            logger.info("Using user-specified image paths.")

        for image_path in images_path:
            logger.info("Processing measurement: %s", image_path)

            # Before dark field correction, crop the Region Of Interest (ROI)
            output = image_path.stem

            # Select first TIFF file within image directory
            tif_files = list(Path(image_path).glob("*.tif"))
            if not tif_files:
                logger.error("No .tif files found in %s", image_path)
                raise ValueError(f"No .tif files found in {image_path}")

            if args.angle_after:
                path_to_ang = flat_path if flat_path is not None else image_path
                tif_ang_files = list(Path(path_to_ang).glob("*.tif"))

                if not tif_ang_files:
                    logger.error("No .tif files found for angle correction in %s", path_to_ang)
                    deg: np.float32 = np.float32(0)
                else:
                    path_to_angle_correction = tif_ang_files[0]
                    image_angle = io.imread(path_to_angle_correction)
                    cords = angles_correction.extracting_coordinates_of_peaks(image_angle)
                    deg: np.float32 = angles_correction.calculating_angles_of_peaks_average(cords)
            else:
                deg: np.float32 = np.float32(0)

            path_to_crop = tif_files[0]
            crop_from_tmptxt = crop_tk.cropImage(path_to_crop)

            if dark_path is not None:
                corrections.correct_darkfield(
                    path_to_dark=dark_path, path_to_images=flat_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                corrections.correct_darkfield(
                    path_to_dark=dark_path, path_to_images=image_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )

                if bright_path is not None:
                    corrections.correct_darkfield(
                        path_to_dark=dark_path, path_to_images=bright_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                    )

                    corrections.correct_brightfield(path_to_bright=bright_path, path_to_images=flat_path)
                    corrections.correct_brightfield(path_to_bright=bright_path, path_to_images=image_path)

                foldername_to = "corrected_images"

            else:
                corrections.crop_without_corrections(
                    path_to_images=image_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )
                corrections.crop_without_corrections(
                    path_to_images=flat_path, crop=crop_from_tmptxt, allow_crop=True, angle=deg
                )

                foldername_to = "crop_without_correction"

            path_to_corrected_images = (Path(image_path) / foldername_to).as_posix()
            path_to_images, path_to_result = directories.create_result_subfolders(
                file_dir=path_to_corrected_images, result_folder=output, sample_folder=""
            )

            type_of_contrast = ("absorption", "scattering", "phase", "phasemap")

            if flat_path is None:
                spatial_harmonics.execute_SHI(path_to_images, path_to_result, mask_period, unwrap, False)

            else:
                path_to_corrected_flat = Path(flat_path).joinpath(foldername_to).as_posix()

                path_to_flat, path_to_flat_result = directories.create_result_subfolders(
                    file_dir=path_to_corrected_flat,
                    result_folder=path_to_result.name,
                    sample_folder="flat",
                )

                spatial_harmonics.execute_SHI(path_to_flat, path_to_flat_result, mask_period, unwrap, True)
                spatial_harmonics.execute_SHI(path_to_images, path_to_result, mask_period, unwrap, False)
                path_to_result = directories.create_corrections_folder(path_to_result)

                for contrast in type_of_contrast:
                    path_to_average_flat = directories.average_flat_harmonics(path_to_flat_result, type_of_contrast=contrast)
                    corrections.correct_flatmask(path_to_result, path_to_average_flat, type_of_contrast=contrast)

                if args.all_2d:
                    if args.average:
                        for contrast in type_of_contrast:
                            path_avg = path_to_result / contrast / "flat_corrections"
                            logger.info("Averaging contrast: %s", contrast)
                            directories.averaging(path_avg, contrast)
                    else:
                        logger.info("Skipping averaging for 2D mode")
                        pass

                elif args.all_3d:
                    for contrast in type_of_contrast:
                        ct_dir = path_to_result / contrast / "flat_corrections"
                        logger.info("Organizing contrast: %s", contrast)
                        directories.organize_dir(ct_dir, contrast)

                else:
                    logger.error("No mode selected (neither all_2d nor all_3d specified)")
                    raise ValueError("No mode selected (neither all_2d nor all_3d specified)")


            if args.export:
                logger.info("Exporting results to %s", path_to_result)
                directories.export_results(path_to_result)


    # # --------------------- To be changed
    # elif args.command == "clean":
    #     if args.clear_cache:
    #         for content in cache_dir.iterdir():
    #             logger.info("Removing cache content: %s", content)
    #             subprocess.run(["rm", "-rf", content.as_posix()], check=True)
    #     # elif args.clear_extra:
    #     #     measurement_directory = Path.cwd()
    #     #     for content in measurement_directory.iterdir():
    #     #         subprocess.run(["rm", "-rf", content.as_posix()], check=True)
    #     else:
    #         logger.error("No cleaning option specified (neither --clear-cache nor --clear-extra)")
    #         raise ValueError("No cleaning option specified. Use --clear-cache or --clear-extra.")

    # elif args.command == "morphostructural":
    #     if args.morphostructural:
    #         cmd = ["python", "morphos.py", "--select_folder", "--manually"]
    #         logger.info("Executing morphostructural analysis with command: %s", cmd)
    #         subprocess.run(cmd, cwd=script_dir, capture_output=True, text=True)
    #     else:
    #         logger.error("Unknown command: %s", args.command)
    #         raise ValueError(f"Unknown command: {args.command}")

    # elif args.command == "preprocessing":
    #     if args.stripes:
    #         current_folder = Path.cwd()
    #         correcting_stripes.correcting_stripes(current_folder)
    #     else:
    #         logger.error("Unknown command: %s", args.command)
    #         raise ValueError(f"Unknown command: {args.command}")

    sys.exit()

